# 理念之争

### 引言

使用Bazel的人，我建议先阅读[https://bazel.build/basics](https://bazel.build/basics)中的这篇文章[https://bazel.build/basics/artifact-based-builds](https://bazel.build/basics/artifact-based-builds)，展示了bazel背后的设计理念，理解了bazel背后的设计理念，对于增量编译，可复现性等概念就会有本质的理解。



### 为什么我要阅读这一页？

研发需要知道bazel提供了什么能力，才能在bazel和其它构建系统之间做选择。同时，用户需要清楚，选择bazel不是选了一个软件，而是一整套平台和解决方案。



### Why Bazel

Bazel是一种比较先进的构建平台，提供了多种便利:

* **支持高级构建语言.**Bazel使用一种抽象的、易读的语言，在高语义级别上描述项目的构建属性。与其他工具不同，Bazel基于库、二进制文件、脚本和数据集的概念进行操作，使您免于编写诸如编译器和链接器等工具的单独调用的复杂性。
* **bazel高效且可靠.** Bazel缓存了所有先前完成的工作，并跟踪文件内容和构建命令的更改。这样，Bazel就知道何时需要重新构建，并仅重新构建需要的部分。可以设置项目以高度并行和增量的方式构建，从而进一步加快构建速度
* **bazel本身支持多平台.** Bazel可以在Linux、macOS和Windows上运行。Bazel可以为多个平台构建二进制文件和可部署包，包括桌面、服务器和移动设备，而这些构建可以来自同一个项目。
* **bazel可以应对不同的构建规模.** 无论是针对多个代码仓库还是处理成千上万个用户基础，Bazel都能够应对，并保持其灵活性和高效性。它通过并行化和增量构建的策略来实现高效的构建过程，并且能够有效地管理大型项目的构建需求。
* **bazel是可拓展的.** 它支持许多编程语言，并且您可以扩展Bazel以支持任何其他语言或框架。.

一部分人认为，相比bazel，Cmake不是更成熟吗？恰恰相反，我个人认为，成熟，只是随大流的一种说法而言，Cmake实际上是在没有工具使用，只能找一种解决问题的方法的情况下选择的工具。它为了解决一个问题，而引入了更多的问题，最终把自己复杂化，有点类似早期的python。

而Bazel设计明确，理念清楚，这种为了解决特定的问题而做的实践，总是比乱七八糟的凑到一起解决某些不确定的问题要方便很多，其开发愿景就是为了

* **保证工程师聚焦于代码开发。**软件开发人员可以专注于编写代码的创造性过程，因为构建和测试的过程已经native 支持，即使是想编辑语言相关的工具链，也有相对应一整套机制方便拓展
* **工程师可以无视本地环境的影响。**环境是“可移动”的，简单来说工程师不用再被一堆莫名其妙的环境配置工作所耽误。
* **项目可以扩展到任何规模的代码库、任何规模的团队。**bazel原生支持的增量测试使团队能够在提交之前充分验证每个更改。无论是增加多语言支持，异或跨平台编译，或者引入更多的代码数量，都不会造成breaking级别的编译灾难（当然，不能有效控制代码的量级，这也是工程人员的失误）

综上，对于软件工程而言，保证开发效率并不是只是说“研发想怎么写，就瞎tm怎么写”，而是如何降低在多人参与开发，且能力不同的情况下所带来的复杂度和依赖复杂度。相比于Cmake的拓展支持，Bazel的原生支持，提供了一种有效的切入点。

综上，我认为bazel是一种目前比较先进的编译方向，当然除了bazel还有please build之类的东西，只不过，我实践bazel比较久。。。

末尾是Bazel和Cmake的优势对比。

| Bazel                  | Cmake                                                                      |
| ---------------------- | -------------------------------------------------------------------------- |
| Remote Cache/Execution | CMake没有内置支持增量编译和分布式编译，但是CMake对增量编译工具ccache/sccache和分布式编译工具distcc/icecc支持良好 |
| Deterministic build    | 灵活性更高，用户可在CMakeLists中调用其他command(shell, built-in commands等)实现自定义功能。        |
| 使用较难，但是依赖分析，使用方式非常清楚   | 简单，易于修改和维护                                                                 |



如果想了解更多，阅读[https://bazel.build/basics](https://bazel.build/basics)
